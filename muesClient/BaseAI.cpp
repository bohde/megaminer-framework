//Copyright (C) 2009 - Missouri S&T ACM AI Team
//Please do not modify this file while building your AI
//See AI.h & AI.cpp for that

#include "BaseAI.h"
#include "game.h"

int BaseAI::maxX()
{
  return getMaxX();
}
int BaseAI::maxY()
{
  return getMaxY();
}
int BaseAI::player0Gold0()
{
  return getPlayer0Gold0();
}
int BaseAI::player0Gold1()
{
  return getPlayer0Gold1();
}
int BaseAI::player0Gold2()
{
  return getPlayer0Gold2();
}
int BaseAI::player1Gold0()
{
  return getPlayer1Gold0();
}
int BaseAI::player1Gold1()
{
  return getPlayer1Gold1();
}
int BaseAI::player1Gold2()
{
  return getPlayer1Gold2();
}
int BaseAI::playerID()
{
  return getPlayerID();
}
int BaseAI::turnNumber()
{
  return getTurnNumber();
}

bool BaseAI::startTurn()
{
  int count = 0;
  count = getBuildingCount();
  buildings.clear();
  buildings.resize(count);
  for(int i = 0; i < count; i++)
  {
    buildings[i] = Building(getBuilding(i));
  }
  count = getBuildingTypeCount();
  buildingTypes.clear();
  buildingTypes.resize(count);
  for(int i = 0; i < count; i++)
  {
    buildingTypes[i] = BuildingType(getBuildingType(i));
  }
  count = getPortalCount();
  portals.clear();
  portals.resize(count);
  for(int i = 0; i < count; i++)
  {
    portals[i] = Portal(getPortal(i));
  }
  count = getTerrainCount();
  terrains.clear();
  terrains.resize(count);
  for(int i = 0; i < count; i++)
  {
    terrains[i] = Terrain(getTerrain(i));
  }
  count = getUnitCount();
  units.clear();
  units.resize(count);
  for(int i = 0; i < count; i++)
  {
    units[i] = Unit(getUnit(i));
  }
  count = getUnitTypeCount();
  unitTypes.clear();
  unitTypes.resize(count);
  for(int i = 0; i < count; i++)
  {
    unitTypes[i] = UnitType(getUnitType(i));
  }
  run();
}


//Convenience Functions - Not generated by the codegen
UnitType BaseAI::getType(Unit& u)
{
  for (int i = 0; i < unitTypes.size(); i++)
  {
    if (unitTypes[i].objectID() == u.unitTypeID())
    {
      return unitTypes[i];
    }
  }
}

BuildingType BaseAI::getType(Building& b)
{
  for (int i = 0; i < buildingTypes.size(); i++)
  {
    if (buildingTypes[i].objectID() == b.buildingTypeID())
    {
      return buildingTypes[i];
    }
  }
}

int BaseAI::distance(int x1, int y1, int z1, int x2, int y2, int z2)
{
  if (z1 != z2)
  {
    return 9999;
  }
  return abs(x1-x2)+abs(y1-y2);
}

bool BaseAI::canMove(int x, int y, int z)
{
  for (int i = 0; i < terrains.size(); i++)
  {
    if (terrains[i].x() == x && terrains[i].y() == y
        && terrains[i].z() == z
        && terrains[i].blockmove() == 1)
      return false;
  }
  for (int i = 0; i < units.size(); i++)
  {
    if (units[i].x() == x && units[i].y() == y &&
       units[i].z() == z && units[i].ownerID() != playerID())
      return false;
  }
  for (int i = 0; i < buildings.size(); i++)
  {
    BuildingType bt = getType(buildings[i]);
    if (z == buildings[i].z() &&
        x >= buildings[i].x() && x < buildings[i].x() + bt.width() &&
        y >= buildings[i].y() && y < buildings[i].y() + bt.height()
        && buildings[i].ownerID() != playerID())
      return false;
  }
  return true;

}

bool BaseAI::canBuild(int x, int y, int z)
{
    if (abs(x) > 10 || abs(y) > 10)
    return false;
  for (int i = 0; i < portals.size(); i++)
  {
    if (portals[i].x() == x && portals[i].y() == y &&
        portals[i].z() == z)
      return false;
  }
  for (int i = 0; i < terrains.size(); i++)
  {
    if (terrains[i].x() == x && terrains[i].y() == y
       && terrains[i].z() == z
       && terrains[i].blockbuild() == 1)
      return false;
  }
  for (int i = 0; i < units.size(); i++)
  {
    if (units[i].x() == x && units[i].y() == y &&
       units[i].z() == z && units[i].ownerID() != playerID())
      return false;
  }
  for (int i = 0; i < buildings.size(); i++)
  {
    BuildingType bt = getType(buildings[i]);
    if (z == buildings[i].z() &&
        x >= buildings[i].x() && x < buildings[i].x() + bt.width() &&
        y >= buildings[i].y() && y < buildings[i].y() + bt.height())
      return false;
  }
  return true;

}

int BaseAI::effDamage(UnitType ut, int level)
{
  return static_cast<int>(ut.damage() * pow(ut.damageExp(), level));
}

int BaseAI::effFood(BuildingType bt, int level)
{
  return static_cast<int>(bt.food() * pow(bt.foodExp(), level));
}


//Returns the gold for the given player in the given time period
int BaseAI::getGold(int playerNum, int z)
{
  int gold = 0;
  switch (3*playerNum+z)
  {
    case 0:
      gold = player0Gold0();
      break;
    case 1:
      gold = player0Gold1();
      break;
    case 2:
      gold = player0Gold2();
      break;
    case 3:
      gold = player1Gold0();
      break;
    case 4:
      gold = player1Gold1();
      break;
    case 5:
      gold = player1Gold2();
      break;
  }
  return gold;
}
   
//Returns the amount of gold a player will receive if an artist of
// the given level paints at a gallery of the given level
int BaseAI::artWorth(int artistLevel, int galleryLevel)
{
  UnitType artist;
  for (int i = 0; i < unitTypes.size(); i++)
  {
    if (strcmp(unitTypes[i].name(), "Artist") == 0)
    {
      artist = unitTypes[i];
    }
  }
  int lvlDiff = abs(artistLevel - galleryLevel);
  return artist.paintBase() + artist.paintLinear() * lvlDiff;
}

//Returns the sum of all the hunger values of all units owned 
//by the given player in the given time period.
int BaseAI::hunger(int playerID, int z)
{
  int hunger = 0;
  for (int i = 0; i < units.size(); i++)
  {
    if (units[i].z() == z && units[i].ownerID() == playerID)
    {
      UnitType ut = getType(units[i]);
      hunger += ut.hunger();
    }
  }
  return hunger;
}

//Returns the sum of all the food produced by all the buildings
//owned by the given player in the given time period.
int BaseAI::foodProduced(int playerID, int z)
{
  int food = 0;
  for (int i = 0; i < buildings.size(); i++)
  {
    if (buildings[i].z() == z && buildings[i].ownerID() == playerID
        && buildings[i].complete() == 1)
    {
      food += effFood(getType(buildings[i]), buildings[i].level());
    }
  }
  return food;
}

