//Copyright (C) 2009 - Missouri S&T ACM AI Team
//Please do not modify this file while building your AI
//See AI.h & AI.cpp for that
#ifndef BASEAI_H
#define BASEAI_H

#include <vector>
#include <ctime>
#include "game.h"
#include "wrappers.h"

//Non codegen includes
#include <math.h>
#include <stdio.h>
#include <string.h>

/// \brief A basic AI interface.

///This class implements most the code an AI would need to interface with the lower-level game code.
///AIs should extend this class to get a lot of builer-plate code out of the way
///The provided AI class does just that.
class BaseAI
{
protected:
  std::vector<Building> buildings;
  std::vector<BuildingType> buildingTypes;
  std::vector<Portal> portals;
  std::vector<Terrain> terrains;
  std::vector<Unit> units;
  std::vector<UnitType> unitTypes;
public:
  int maxX();
  int maxY();
  ///Player 0's past gold
  int player0Gold0();
  ///Player 0's present gold
  int player0Gold1();
  ///Player 0's future gold
  int player0Gold2();
  ///Player 1's past gold
  int player1Gold0();
  ///Player 1's present gold
  int player1Gold1();
  ///Player 1's future gold
  int player1Gold2();
  ///Player Number; either 0 or 2
  int playerID();
  int turnNumber();
  
  ///
  ///Make this your username, which should be provided.
  virtual const char* username() = 0;
  ///
  ///Make this your password, which should be provided.
  virtual const char* password() = 0;
  ///
  ///This is run on turn 1 before run
  virtual void init() = 0;
  
  virtual bool run() = 0;

  bool startTurn();

  //Convenience Functions - Not generated by the codegen
  UnitType getType(Unit& u);
  BuildingType getType(Building& b);

  //Returns the manhattan distance (aka, not diagonally)
  int distance(int x1, int y1, int z1, int x2, int y2, int z2);

  //Distance between mappable objects.
  template <typename T1, typename T2>
  int distance(T1& a, T2& b)
  {
    return distance(a.x(), a.y(), a.z(), b.x(), b.y(), b.z());
  }

  //Returns true if my units can pass through this point
  bool canMove(int x, int y, int z);

  //Returns true if i could build something here
  bool canBuild(int x, int y, int z);

  //Returns the price of a buildingType or unitType at a given level
  template <typename T>
  int effPrice(T myType, int level)
  {
    return static_cast<int>(myType.price() * pow(myType.priceExp(), level));
  }

  //Returns the amount of damage delt by a unitType at a given level.
  //Does not account for the target's armor.
  int effDamage(UnitType ut, int level);

  //Returns the max HP for a unitType or buildingType at a given level.
  template <typename T>
  int effMaxHP(T myType, int level)
  {
    return static_cast<int>(myType.hp() * pow(myType.hpExp(), level));
  }

  //Returns the armor rating of a unitType or buldingType at a given level
  template <typename T>
  int effArmor(T myType, int level)
  {
    return static_cast<int>(myType.armor() * pow(myType.armorExp(), level));
  }

  //Returns the food produced by the given buildingType at a given level
  int effFood(BuildingType bt, int level);

  //Returns the gold for the given player in the given time period
  int getGold(int playerNum, int z);

  //Returns the amount of gold a player will receive if an artist of
  // the given level paints at a gallery of the given level
  int artWorth(int Artistlevel, int galleryLevel);

  //Returns the sum of all the hunger values of all units owned 
  //by the given player in the given time period.
  int hunger(int playerID, int z);

  //Returns the sum of all the food produced by all the buildings
  //owned by the given player in the given time period.
  int foodProduced(int playerID, int z);


};

#endif
